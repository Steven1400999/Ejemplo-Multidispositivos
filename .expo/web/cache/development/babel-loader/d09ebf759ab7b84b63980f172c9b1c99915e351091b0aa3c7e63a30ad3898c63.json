{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { snapValueToStep as $vhjCi$snapValueToStep, clamp as $vhjCi$clamp, useControlledState as $vhjCi$useControlledState } from \"@react-stately/utils\";\nimport { useFormValidationState as $vhjCi$useFormValidationState } from \"@react-stately/form\";\nimport { NumberFormatter as $vhjCi$NumberFormatter, NumberParser as $vhjCi$NumberParser } from \"@internationalized/number\";\nimport { useState as $vhjCi$useState, useMemo as $vhjCi$useMemo, useCallback as $vhjCi$useCallback } from \"react\";\nfunction $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {\n  var minValue = props.minValue,\n    maxValue = props.maxValue,\n    step = props.step,\n    formatOptions = props.formatOptions,\n    value = props.value,\n    defaultValue = props.defaultValue,\n    onChange = props.onChange,\n    locale = props.locale,\n    isDisabled = props.isDisabled,\n    isReadOnly = props.isReadOnly;\n  if (value === null) value = NaN;\n  if (!isNaN(value)) {\n    if (!isNaN(step)) value = (0, $vhjCi$snapValueToStep)(value, minValue, maxValue, step);else value = (0, $vhjCi$clamp)(value, minValue, maxValue);\n  }\n  if (!isNaN(defaultValue)) {\n    if (!isNaN(step)) defaultValue = (0, $vhjCi$snapValueToStep)(defaultValue, minValue, maxValue, step);else defaultValue = (0, $vhjCi$clamp)(defaultValue, minValue, maxValue);\n  }\n  var _ref = (0, $vhjCi$useControlledState)(value, isNaN(defaultValue) ? NaN : defaultValue, onChange),\n    _ref2 = _slicedToArray(_ref, 2),\n    numberValue = _ref2[0],\n    setNumberValue = _ref2[1];\n  var _ref3 = (0, $vhjCi$useState)(function () {\n      return isNaN(numberValue) ? \"\" : new (0, $vhjCi$NumberFormatter)(locale, formatOptions).format(numberValue);\n    }),\n    _ref4 = _slicedToArray(_ref3, 2),\n    inputValue = _ref4[0],\n    setInputValue = _ref4[1];\n  var numberParser = (0, $vhjCi$useMemo)(function () {\n    return new (0, $vhjCi$NumberParser)(locale, formatOptions);\n  }, [locale, formatOptions]);\n  var numberingSystem = (0, $vhjCi$useMemo)(function () {\n    return numberParser.getNumberingSystem(inputValue);\n  }, [numberParser, inputValue]);\n  var formatter = (0, $vhjCi$useMemo)(function () {\n    return new (0, $vhjCi$NumberFormatter)(locale, _objectSpread(_objectSpread({}, formatOptions), {}, {\n      numberingSystem: numberingSystem\n    }));\n  }, [locale, formatOptions, numberingSystem]);\n  var intlOptions = (0, $vhjCi$useMemo)(function () {\n    return formatter.resolvedOptions();\n  }, [formatter]);\n  var format = (0, $vhjCi$useCallback)(function (value) {\n    return isNaN(value) || value === null ? \"\" : formatter.format(value);\n  }, [formatter]);\n  var validation = (0, $vhjCi$useFormValidationState)(_objectSpread(_objectSpread({}, props), {}, {\n    value: numberValue\n  }));\n  var clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === \"percent\" && isNaN(step)) clampStep = 0.01;\n  var _ref5 = (0, $vhjCi$useState)(numberValue),\n    _ref6 = _slicedToArray(_ref5, 2),\n    prevValue = _ref6[0],\n    setPrevValue = _ref6[1];\n  var _ref7 = (0, $vhjCi$useState)(locale),\n    _ref8 = _slicedToArray(_ref7, 2),\n    prevLocale = _ref8[0],\n    setPrevLocale = _ref8[1];\n  var _ref9 = (0, $vhjCi$useState)(formatOptions),\n    _ref10 = _slicedToArray(_ref9, 2),\n    prevFormatOptions = _ref10[0],\n    setPrevFormatOptions = _ref10[1];\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n  var parsedValue = (0, $vhjCi$useMemo)(function () {\n    return numberParser.parse(inputValue);\n  }, [numberParser, inputValue]);\n  var commit = function commit() {\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? \"\" : format(numberValue));\n      return;\n    }\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n    var clampedValue;\n    if (isNaN(step)) clampedValue = (0, $vhjCi$clamp)(parsedValue, minValue, maxValue);else clampedValue = (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, step);\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n  var safeNextStep = function safeNextStep(operation, minMax) {\n    var prev = parsedValue;\n    if (isNaN(prev)) {\n      var newValue = isNaN(minMax) ? 0 : minMax;\n      return (0, $vhjCi$snapValueToStep)(newValue, minValue, maxValue, clampStep);\n    } else {\n      var _newValue = (0, $vhjCi$snapValueToStep)(prev, minValue, maxValue, clampStep);\n      if (operation === \"+\" && _newValue > prev || operation === \"-\" && _newValue < prev) return _newValue;\n      return (0, $vhjCi$snapValueToStep)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n    }\n  };\n  var increment = function increment() {\n    var newValue = safeNextStep(\"+\", minValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n  var decrement = function decrement() {\n    var newValue = safeNextStep(\"-\", maxValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n  var incrementToMax = function incrementToMax() {\n    if (maxValue != null) {\n      setNumberValue((0, $vhjCi$snapValueToStep)(maxValue, minValue, maxValue, clampStep));\n      validation.commitValidation();\n    }\n  };\n  var decrementToMin = function decrementToMin() {\n    if (minValue != null) {\n      setNumberValue(minValue);\n      validation.commitValidation();\n    }\n  };\n  var canIncrement = (0, $vhjCi$useMemo)(function () {\n    return !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(maxValue) || (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation(\"+\", parsedValue, clampStep) <= maxValue);\n  }, [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  var canDecrement = (0, $vhjCi$useMemo)(function () {\n    return !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(minValue) || (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation(\"-\", parsedValue, clampStep) >= minValue);\n  }, [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  var validate = function validate(value) {\n    return numberParser.isValidPartialNumber(value, minValue, maxValue);\n  };\n  return _objectSpread(_objectSpread({}, validation), {}, {\n    validate: validate,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin,\n    canIncrement: canIncrement,\n    canDecrement: canDecrement,\n    minValue: minValue,\n    maxValue: maxValue,\n    numberValue: parsedValue,\n    setNumberValue: setNumberValue,\n    setInputValue: setInputValue,\n    inputValue: inputValue,\n    commit: commit\n  });\n}\nfunction $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {\n  var result = operator === \"+\" ? value1 + value2 : value1 - value2;\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    var value1Decimal = value1.toString().split(\".\");\n    var value2Decimal = value2.toString().split(\".\");\n    var value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n    var value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n    var multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n    result = operator === \"+\" ? value1 + value2 : value1 - value2;\n    result /= multiplier;\n  }\n  return result;\n}\nexport { $de67e98908f0c6ee$export$7f629e9dc1ecf37c as useNumberFieldState };","map":{"version":3,"names":["$de67e98908f0c6ee$export$7f629e9dc1ecf37c","props","minValue","maxValue","step","formatOptions","value","defaultValue","onChange","locale","isDisabled","isReadOnly","NaN","isNaN","$vhjCi$snapValueToStep","$vhjCi$clamp","_ref","$vhjCi$useControlledState","_ref2","_slicedToArray","numberValue","setNumberValue","_ref3","$vhjCi$useState","$vhjCi$NumberFormatter","format","_ref4","inputValue","setInputValue","numberParser","$vhjCi$useMemo","$vhjCi$NumberParser","numberingSystem","getNumberingSystem","formatter","_objectSpread","intlOptions","resolvedOptions","$vhjCi$useCallback","validation","$vhjCi$useFormValidationState","clampStep","style","_ref5","_ref6","prevValue","setPrevValue","_ref7","_ref8","prevLocale","setPrevLocale","_ref9","_ref10","prevFormatOptions","setPrevFormatOptions","Object","is","parsedValue","parse","commit","length","undefined","clampedValue","safeNextStep","operation","minMax","prev","newValue","$de67e98908f0c6ee$var$handleDecimalOperation","increment","commitValidation","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value1","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"sources":["C:\\Users\\Stefano\\Ejemplo1\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\index.ts","C:\\Users\\Stefano\\Ejemplo1\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useNumberFieldState} from './useNumberFieldState';\n\nexport type {NumberFieldStateOptions} from './useNumberFieldState';\nexport type {NumberFieldState} from './useNumberFieldState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface NumberFieldState extends FormValidationState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /** Sets the number value. */\n  setNumberValue(val: number): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\nexport interface NumberFieldStateOptions extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateOptions\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  if (value === null) {\n    value = NaN;\n  }\n\n  if (!isNaN(value)) {\n    if (!isNaN(step)) {\n      value = snapValueToStep(value, minValue, maxValue, step);\n    } else {\n      value = clamp(value, minValue, maxValue);\n    }\n  }\n\n  if (!isNaN(defaultValue)) {\n    if (!isNaN(step)) {\n      defaultValue = snapValueToStep(defaultValue, minValue, maxValue, step);\n    } else {\n      defaultValue = clamp(defaultValue, minValue, maxValue);\n    }\n  }\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => (isNaN(value) || value === null) ? '' : formatter.format(value), [formatter]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: numberValue\n  });\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let [prevValue, setPrevValue] = useState(numberValue);\n  let [prevLocale, setPrevLocale] = useState(locale);\n  let [prevFormatOptions, setPrevFormatOptions] = useState(formatOptions);\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsedValue, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsedValue, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsedValue;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n    validation.commitValidation();\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n      validation.commitValidation();\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n      validation.commitValidation();\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    ...validation,\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setNumberValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}